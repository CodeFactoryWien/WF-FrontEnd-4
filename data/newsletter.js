const newsletter = {
    news: [
        "HASKELL WEEKLY -- Newsletter --I’ve made it to the final stage of my computer science PhD, you know the one where you start looking for jobs, get yourself a copy of Cracking the Coding Interview (affiliate link), and realise that you haven’t done much of the kind of programming that about half of the companies expect you to do at their job interviews (and at their job interviews only). At some point in the book, it says “know how to implement these data structures by heart: dynamically sized arrays, hash tables, […], binary heaps, […]”. It dawned on me that I remember the heap property and the heap interface, but not how to implement it. I was horrified when I remembered despite conceptually being a tree, binary heaps are implemented using arrays. Despite having used Haskell as my primary language, decided to implement it in Ruby—my prior primary language. Some time and indexing errors later, I got it working. Then ported it to Haskell’s using the ST monad. After writing STRef one too many times, I got that working too, but it left much to be desired. “Save the trees” yelled my terminal! Finally, I consulted Dr Chris Okasaki’s Purely Functional Data Structures (affiliate link). A leftist heap is one of the first data structures discussed in the book. It has better worst-case asymptotic complexity than the binary heap, is represented as a tree, and doesn’t need mutation. Great! I was pleased to have a heap under my belt that was much easier to remember and much more difficult to get its implementation wrong. Staring at it for a while (and being bored while trying to find various substrings with various properties in linear time and constant space under an hour over the phone), I got a burning desire to encode the titular properties of a leftist heap using fancy types. Having listened to hundreds of people complain about the state of type-level programming in Haskell, I found the process to be rough around the edges, but functional (see what I did there).",
        "A leftist heap -- Since we’ll go through the trouble of implementing leftist heaps multiple times, let’s spend a second on comparing it to array-based binary heaps. Why bother with the leftist heap? It is persistent (hence better suited for multi-threaded computation), both conceptually and implementation-wise a tree, and more resilient against off-by-one errors. Why bother with the array-based binary heap? Better average case complexity of insertions; its operations are in place; and it probably performs better in practice because of good locality of reference (this is a hunch and I’d like to be proven wrong). We can also look at their complexities more concretely. Leftist heaps have  worst-case complexity for insertion and deleting the maximum, while maintaining  complexity for finding the maximum. Building a heap out of a collection is . So far we’re on par with binary heaps. But we can do one better. While merging binary heaps is , it’s only  for leftist heaps. In fact, this is why insertion and deletion are .",
        "New book about programming with Haskell -- Amazon paperback $29.99  | DRM-free PDF $19.99. In Haskell from the Very Beginning John Whitington takes a no-prerequisites approach to teaching the basics of a modern general-purpose programming language. Each small, self-contained chapter introduces a new topic, building until the reader can write quite substantial programs. There are plenty of questions and, crucially, worked answers and hints. Haskell from the Very Beginning will appeal both to new programmers, and to experienced programmers eager to explore functional languages such as Haskell. It is suitable both for formal use within an undergraduate or graduate curriculum, and for the interested amateur.",
        "Posted on October 4, 2019 by Robert Kreuzer One of the questions that any software engineer will face at one point in their career is when is the BIG rewrite the right thing to do? And is it ever? For small programs, where it would be a question of a few days or a few weeks to rewrite them, it will generally not be worth pondering this question for very long, and in most cases it will be better to just get started on either fixing the existing implementation or on rewriting it. For small programs it is possible for one person to keep all of their state, and their logic, and their invariants in their head, but for big programs this does not work. Big programs are qualitatively different from small programs in that they consist of many moving and inter-locking parts, each with their own design decisions, trade-offs, and underlying assumptions. It is possible, and beneficial, to look at each part in isolation, but you also have to zoom out and look at the emerging picture of the whole system. For such systems it is no longer possible to keep everything in your head and this makes it much harder to make an informed decision on whether a rewrite would be the right thing to do or not. In this post we will try to give a more general framework on how to answer this question for a specific project and we will also tell our story of rewriting the core data processing system that powers Channable. Backstory -- We used to be heavily invested into Apache Spark - but we have been Spark-free for six months now. We had already taken the decision to move away from Spark and HDFS in November 2017, but it took us more than a year before we could turn off the last Spark servers. We had written our core data processing system in Scala, on top of Spark, and we had added many features to it over the years. To fully replace it with a new system took a humongous engineering effort, since we did not only have to replace our own application, but also all of the features of Spark and HDFS that we relied upon. One key insight early-on was that we could not replace our current system all at once, it was simply too big for this. Instead we would have to do it piece-by-piece, running the old and the new system side-by-side and gradually migrating one feature after another.",
        "Hi! Welcome to the Haskell Weekly podcast. I'm your host Taylor Fausak. I'm the lead engineer at IT Pro TV. With me today is Cody, one of the engineers on my team. Thanks for joining me today, Cody.  >> Yeah, no problem. I'm excited to talk about our topic today.  >> Yeah what topic is that? What are we gonna be talking about today?  >> We came across the blog post and hope to dig into that.  >> Sounds good to me! Let's jump right in. So what is this blog post about, Cody?  >> It's about the event log and how you can use it to get a picture of what GHC is doing not only about the events it already throws but adding your own user-defined events to get a complete picture of the things that you do care about in terms of time and space.  >> Sounds cool! I think I could probably guess based on context clues but what exactly is the event log?  >> It is just a generic list of events written to a file inside of the binary.  >> Alright so that sounds like a pretty lightweight file format. The way that I'm most used to looking at the performance of Haskell programs is using profiling,. How does the event log compare with profiling?  >> So a big advantage it has they mentioned it in a different order in the blog post but I think the last thing mentioned is: the biggest reason to use it; it has a lot less impact on performance and you can keep all your same optimizations you'd be running anyway.  >> That sounds nice.  >> And get an eye on those.  >> Yeah because I know that with profiling you have to rebuild basically everything, right?  >> Yeah, and it can really take quite a bit. Then you have something that you're uncomfortable without putting in production.  >> Right because we use Haskell here at IT Pro TV and if you try to rebuild our project with profiling, I think you're probably going to want to go get a coffee, maybe even go get lunch while that happens because it's got to build you know two hundred some-odd dependencies and rebuild the whole project. It's a lot of work for the compiler to do.  >> Yeah last time I did it it took at least a good 30 minutes.  >> And then once you've got that built like you said I'm not super comfortable throwing that in production because profiling defeats so many of the optimizations that we kind of rely on to have a fast service.  >> Right and if you're defeating those optimizations that means you're getting a fuzzier picture of what the performance was like anyway. So in that way the event log here let's just have a lot more clear look at that and take more clear actions as a result.  >> Right and to put a fine point on that, when you enable profiling you can change the behavior in terms of performance of the thing that you're looking at. So you may identify some part of your program that's slow and turn on profiling to figure out why it's slow and then once you do that some other part of your program turns out to be the hot spot with profiling enabled. So the event log seems like a good way to avoid that problem but still get a peek into the performance characteristics.  >> Right, and if you do go ahead and need more information from profiling and you can keep in mind what you learn from the event log and have at least an idea of things that maybe are just noise in the profile.  >> Yeah it's you know by no means one or the other. You can definitely use both. So with the event log I think GHC has some custom tooling around making events but there's some stuff in Debug.Trace which is a handy little module that provides a lot of stuff for like logging out from pure functions. That's the way that I most commonly use it. But it seems like it's recently gotten some other stuff for logging events, could you talk about that?  >> Yeah they recently added the withTraceIO function and I believe a couple others. Oh sorry it was traceEvent and traceEventIO, traceMarker and traceMarkerIO. That lets you have user-defined markers and that's really powerful. That lets you see, you know ,when that spike in heap usage happens, what marker is it near. What logical thing you defined is happening is going on.  >> Right, so we've been talking a lot about events which are you know just kind of ad hoc something happened, but a marker it sounds like is a bigger picture than that?  >> Right. This is amongst all those events that are happening, what function just happened. Or not even what function but at a higher level what unit of work is happening.  >> Right, so like right now we're in the, you know, collecting dependencies part of the job, and then now we're on the optimizing part, and now we're on the linking part. Those are those might be markers.  >> Exactly",
        "About the Tech We use Haskell with the Yesod framework, and we use Elm for parts of the UI where we feel it makes sense. Otherwise, we try to keep most logic on the server in our fairly traditional monolithic application. Parts of our system are Event Sourced, and we're mostly using PostgreSQL for persistence, with a bit of Redis thrown in for good measure. Our infrastructure is managed with Nix on AWS. We do not have any legacy system written in PHP or Ruby or whatever, as many companies do. We do not have a micro-services architecture, and we have no intention to build one. --About You -- You must have demonstrable experience building things in idiomatic Haskell, and you should have a solid understanding of how web applications typically work. A degree is not required. You will need to be able to write SQL queries. In most cases we write ours with Persistent/Esqueleto. You should be able to communicate clearly in English, but you do not need to speak excellent English. As most of our communication is written and asynchronous, it is important to us that we find someone who can describe their approach to problem solving in written form — we can't have people working in complete isolation, and occasionally throwing completed tasks over the fence. You have flexible working hours and you can work from anywhere, though this is a full-time position and the expectation is that of work based on a traditional 40 hour week. We are especially interested in people with real, not-just-superficial skills in various forms of testing in Haskell, and also with Nix.",
        "Bazel is a build tool originally created by Google. The key attributes of Bazel are Bazel is a polyglot build tool, supporting many different programming languages. This enables Bazel to be fast, because it can have a global and fine-grained view of the dependency graph, even across language boundaries. Bazel tries hard to guarantee build correctness. This means that after making a few localized changes to your source code, you don't need to start your build from scratch to be confident that others get the same result. Incremental builds are guaranteed to yield the same result as full builds (under mild conditions we won't discuss here). This also means that it's safe to distribute builds to a large cluster of remote machines to make it finish fast. You still get the same result. Bazel is extensible. You can teach Bazel to build code in new programming languages that it didn't know about out-of-the-box. Doing so requires getting familiar with a simple Python-like language called Starlark. Unlike Make or Shake rules, mechanisms and conventions exist to easily reuse Bazel rules across projects, leading to the emergence of an entire ecosystem of rules that build on each other. Internally, Google uses a variant of Bazel to build most of their billions of lines of source code, thousands of times a day. If your project has lots of components in a variety of different languages and you don't want the hassle of lots of build systems too, or if you simply want your builds to remain fast no matter how big your project grows, you should probably be using Bazel (or Buck, Facebook's equivalent).The tool expects two types of files in your project: One or more BUILD files. Each BUILD file declares a set of targets. Each target is an instance of a build rule, like haskell_library for any reusable component in your project, or haskell_binary for the executables, or miscellaneous other build rules (like API documentation). See the tutorial for a longer introduction. A WORKSPACE file that allows you to invoke macros that perform some autodiscovery and automatically generate BUILD files from, say, third-party package metadata. Here's how our solution to build third-party code works: We define two new build rules: haskell_cabal_library and haskell_cabal_binary. These are like haskell_library and haskell_binary, respectively, except that Cabal is used to build the targets, rather than calling GHC (the Glasgow Haskell Compiler) directly. A macro called stack_snapshot generates a BUILD file that declares a target for each Cabal package in the given snapshot that we'll be using in our project, directly or indirectly.",
        "We recently found ourselves looking at Go by ExampleGo by Example with envy. It is such an expedient introduction to the Go language; it does not seek to explain everything but contains much in brevity. We love Haskell because it can be understood thoroughly. And that’s how we love to write about it: Constructed from the ground up, explaining everything, each concept firmly established before we put it into use. But each style of writing has its appropriate time and place. The by-example style is particularly great for getting an initial impression of a language. You can see what entire programs look like, and the commentary placed to the side augments the examples but does not interrupt them. The code is given some reign to speak for itself. The Phrasebook -- We are excited to announce The Haskell Phrasebook.The Haskell Phrasebook Taking an approach similar to Go by Example, it emphasizes how to get started writing programs quickly. In a departure from our usual style, this project does not explain everything in full detail; the Phrasebook’s role is only to be a traveler’s starting point and quick reference. We have launched the Phrasebook with 14 demonstrations of topics ranging from if-then-else expressions to transactional concurrency, and there is a lot more to come. The Haskell Phrasebook → The Phrasebook is totally free, and our intent is to make it the place to point Haskell newcomers for free introductory reading. If you share our vision, please consider helping us out: become a Type Classes member or contribute on Liberapay. This is how we are able to keep producing Haskell learning materials full-time.",
        "Hello and welcome to the Haskell weekly podcast as you might have guessed this show is about Haskell, which is a purely functional programming language. I'm your host Dustin Segers and I'm an engineer here at IT Pro TV.  >> Hi, I'm Cody Goodman. I'm a senior engineer here at IT Pro TV. What are we talking about today Dustin?  >> We're talking about game development and Haskell. I thought it would be cool to kind of bring together my love of game development and video games in general and Haskell, which is what I use daily here at IT Pro TV. I actually have a few questions for you and I figured it would be cool to kind of just look into the Haskell Game Dev community and space and see what all was out there.  >> Yeah. I think a lot of people are in your position, you know, if you browse the Haskell subreddit, you'll see occasionally questions about people want to make games and people frustrated trying to make games. So if you don't take the right path, it can be pretty frustrating. One recommendation I've seen over the years and tried a little myself is to start out with a 2D library called gloss.  >> Gotcha. Have you ever heard of it?  >> Yeah actually are our lead engineer. I think he did a few just very basic games using gloss. I heard it was super intuitive and quick to get something up on the screen.  >> Right, right. Yeah. That's that's one of the reasons I recommend it and I think a lot of other people recommend it is you can you can draw window and draw a circle and a single line and it's all and you know plain English words that you might be able to guess yourself.  >> Nice.  >> You know gloss is really aimed at simplicity. There's a ton of tutorials available, not just like basic tutorials, but tutorials of you know, how do you make pong?  >> Yeah.  >> Right. It's more of an end to end thing which has Haskells sorely lacking in other areas, but when you're just getting started, it's a new paradigm, a new language. You you need you know a little bit of hand-holding. You just get all the way from point A to point B at least exactly least once.  >> That's it. So gloss seems really attractive to me in that aspect mainly because I'm not super proficient at Haskell. I've only been doing it for a little while, but I do enjoy it and I think I have more experience in game development mainly as a hobby right versus you know programming in Haskell. So I would like to merge both of them and gloss seems like a pretty good pretty good way to do that.  >> Yeah, and for people trying to merge their game development experience or interest in their love Haskell, you'll probably run into a functional reactive programming which you have few are really in proficient in a school. It can be a bit of a mind Bender wrap your head around that.  >> Gotcha, yeah. I actually just doing a little bit of research before this podcast. We stumbled upon FRP functional reactive programming and then also just your classic mean Iterating over your main game Loop. And do you have any like, I guess a concise way, if you could explain functional reactive programming to those who don't know?  >> I didn't come up with the best answer myself, but I looked around and hope I'd say the name right here T cange Elvis as they talk on answering that that question, you know, you have to have a whole talk to answer it yet. He says if I had to summarize it in one sentence, I would say that functional reactive programming is programming with time varying values. Now, that's not the most satisfying answer person one who might already be overwhelmed.  >> Yeah. Yeah, but basically that's for lack of anything better to use at this moment. It's state right like so I represent State.  >> Yeah. It's a lot like state. The so it's still encodes the information that state would encode the difference would be that the way that these things composed together or different we won't get too deep into that. And that's why the reasons we recommend gloss to start out with. Yeah, so you can just you know gloss over FRP I guess.",
        "Sucky software >>>> The hardware is nice: water proof, easy to install, bright, long-lasting battery. But the software, oh my! You need Windows to load your own pictures onto the device, and the application is really unpleasant to use, you can’t easily save your edits and sequences of images and so on. But also the software on the device itself (which sports a microcontroller) was unsatisfying: The transformation it applies to the image assumes that the bar of LEDs goes through the center of the wheel. Obviously that is wrong, as there is the hub. With a small hub the difference is not so bad, but I have rather large hubs (a generator in the front hub, and internal gears in the rear hub), and this make the image not stable, but jump back and forth a bit. Time to DIY! So obviously I had to do something about it. At first I planned to to just find out how to load my own pictures onto the hardware, using the existing software on the device. So I needed to find out the protocol. I was running their program on Windows in VirtualBox, and quickly noticed that the USB connection that you use to load your data onto the YQ8003 is actually a serial-over-USB port. I found a sniffer for serial communication and used that to dump what the Windows app sent to the device. That was all pretty hairy, and I only did it once (and deleted the Windows setup soon), but luckily one dump was sufficient. I did not find out where in the data sent to the light the image was encoded. But I did find that the protocol used to talk to the device is a standard protocol to talk to microcontrollers, something called “STC ISP”. With that information, I could find out that the microcontroller is a STC12LE5A60S2 with 22MHz and 60KB of RAM, and that it is “8051 compatible”, whatever that means. So this is how I, for the first and so far only time, ventured into microcontroller territory. It was pretty straight-forward to get a toolchain to compile programs for this microcontroller (using sdcc) and to upload code to it (using stcgal), and I could talk to my code over the serial port. This is promising! Reverse engineering -- I also quickly found out how the magnet (which the device uses to notice when the wheel has done one rotation) is accessed: It triggers interrupt 0. But finding out how to actually access the LEDs and might them light up was very tricky. This kind of information is not specific to the microcontroller (STC12LE5A60S2), for which I could find documentation, but really depends on how it is wired up. I was able to extract, from the serial port communication dump mentioned earlier, the firmware in a way I could send it to the microcontroller. So I could always go back to a working state. Moreover I could disassemble that code, and try to make sense of it. But I could not make sense of it, i.e. could not understand . So if thinking does not help, maybe brute force does? I wrote a program that would take the working firmware, zero out parts of it. Then I would try that firmware and note if it still works. This way, my program would zero out ever more of the firmware, until only a few instructions are left that would still make the LEDs light up. In the end I had, I think, 13 instructions left that made the LEDs light up lightly. Success! Or so I thought … the resulting program was pretty non-sensical. It essentially increments a value and writes another value to the address stored in the first value. So it just spews data all over the address range, wrapping around when at the end. No surprise it triggers the LEDs somewhere along the way… (Still, I published the program to minimize binary data under the name bisect-binary – maybe you’ll find it useful for something.) I actually don’t remember how I eventually figured out what to do, and which bytes and bits to toggle in which order. Maybe more reading, and some advice to look for from people who know more about LEDs."
    ]
}